#Jamie Armstrong
#EENG350 Demo 2 Computer Vision Subsystem
#Angle and Distance Detection

import adafruit_character_lcd.character_lcd_rgb_i2c as character_lcd
from picamera.array import PiRGBArray
from picamera import PiCamera
import cv2.aruco as aruco
import smbus2
import numpy as np
import pickle
import board
import busio
import time
import cv2

# Global Variables
bus = smbus2.SMBus(1)
address = 0x04
desiredPos = 0
lcd_columns = 16
lcd_rows = 2
offSet = 0

# This is used to write a value to the arduino via I2C
def writeText(value):
    bus.write_byte_data(address, offSet, value)
    return -1

# initialize the camera, grab reference to raw camera capture
camera = PiCamera()

width, height = (640, 480)
camera.resolution = (width, height)
camera.framerate = 20
rawCapture = PiRGBArray(camera, size=camera.resolution)

# Allow the camera to warmup
time.sleep(0.1)

# Set ISO to desired value
camera.iso = 100

# Wait for automatic gain control to settle
time.sleep(2)

# Now fix values
camera.shutter_speed = camera.exposure_speed
camera.exposure_mode = 'off'
g = camera.awb_gains
camera.awb_mode = 'off'
camera.awb_gains = g

# Camera Parameters
objects = []
with (open("camera_params.p", "rb")) as openfile:
    while True:
        try:
            objects.append(pickle.load(openfile))
        except EOFError:
            break

K = objects[0]['M']
distCoeffs = objects[0]['coefs_dist']

#distCoeffs = [-.010, .045, -.007, .003, -.163]

# Create dictionary and parameters
aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)
parameters = aruco.DetectorParameters_create()
MARKER_LENGTH = 5  # cm

# capture frames from the camera
for frame in camera.capture_continuous(rawCapture, format="bgr", use_video_port=True):
    # grab the raw NumPy array representing the image, then initialize the timestamp
    # and occupied/unoccupied text
    image = frame.array

    # clear the stream in pre
    rawCapture.truncate(0)

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Detect Markers
    corners, ids, rejectedImgPoints = aruco.detectMarkers(gray, aruco_dict, parameters=parameters)

    # Get Pose
    rvecs, tvecs, _ = aruco.estimatePoseSingleMarkers(corners, markerLength=MARKER_LENGTH, cameraMatrix=K, distCoeffs=distCoeffs)

    if ids is None:
        pass
#        print("no markers")
    
    else:
        marker_id = ids[0, 0]
        marker_corners = corners[0]
        rvec = rvecs[0]
        tvec = tvecs[0]
        
        # Display axis on marker
        #image = aruco.drawAxis(image, cameraMatrix=K, distCoeffs=None, rvec=rvec, tvec=tvec, length = 1)
        
        #angle and distance detection
        phi = (-1) * np.arctan2(tvec[0,0], tvec[0,2])
        rho = tvec[0][2]
#        print("rho: ", rho)
#        print("phi: ", np.rad2deg(phi), "\n")
        #print(K)
#        print(distCoeffs)
        phi_cnts = int(np.rad2deg(phi) * 3200 / 360)
#        print(phi_cnts)
        #This will write and read the quadrant from and to the arduino
        if (ids != None):
            if(phi_cnts < 0):
                offSet = 0
                offSet = int(offSet)
                phi_cnts = abs(phi_cnts)
            else:
                offSet =  1
                offSet = int(offSet)
                phi_cnts = abs(phi_cnts)
        if (rho < 30):
            offSet = 2
            offSet = int(offSet)
        if(ids is None):
            offSet = 3
            offSet = int(offSet)
        try:                       #Added for error handling
            writeText(phi_cnts)
        except:                    #Added for error handling
            writeText(phi_cnts)
            
        
    #image = aruco.drawDetectedMarkers(image, corners)

    cv2.imshow('frame', gray) 
    if cv2.waitKey(1) == ord('q'):
        break
     
cv2.destroyAllWindows()



